[
{"created":"20240318125111763","text":"/*\\\ntitle: $:/plugins/tiddlywiki/multiwikiserver/store/sql-tiddler-store.js\ntype: application/javascript\nmodule-type: library\n\nHigher level functions to perform basic tiddler operations with a sqlite3 database.\n\nThis class is largely a wrapper for the sql-tiddler-database.js class, adding the following functionality:\n\n* Validating requests (eg bag and recipe name constraints)\n* Synchronising bag and recipe names to the admin wiki\n* Handling large tiddlers as attachments\n\n\\*/\n\n(function() {\n\n/*\nCreate a tiddler store. Options include:\n\ndatabasePath - path to the database file (can be \":memory:\" to get a temporary database)\nadminWiki - reference to $tw.Wiki object into which entity state tiddlers should be saved\nattachmentStore - reference to associated attachment store\nengine - wasm | better\n*/\nfunction SqlTiddlerStore(options) {\n\toptions = options || {};\n\tthis.attachmentStore = options.attachmentStore;\n\tthis.adminWiki = options.adminWiki || $tw.wiki;\n\tthis.entityStateTiddlerPrefix = \"$:/state/MultiWikiServer/\";\n\t// Create the database\n\tthis.databasePath = options.databasePath || \":memory:\";\n\tvar SqlTiddlerDatabase = require(\"$:/plugins/tiddlywiki/multiwikiserver/store/sql-tiddler-database.js\").SqlTiddlerDatabase;\n\tthis.sqlTiddlerDatabase = new SqlTiddlerDatabase({\n\t\tdatabasePath: this.databasePath,\n\t\tengine: options.engine\n\t});\n\tthis.sqlTiddlerDatabase.createTables();\n\tthis.updateAdminWiki();\nconsole.log('yippie!!!');\n}\n\n/*\nReturns null if a bag/recipe name is valid, or a string error message if not\n*/\nSqlTiddlerStore.prototype.validateItemName = function(name) {\n\tif(typeof name !== \"string\") {\n\t\treturn \"Not a valid string\";\n\t}\n\tif(name.length > 256) {\n\t\treturn \"Too long\";\n\t}\n\t// Removed ~ from this list temporarily\n\tif(!(/^[^\\s\\u00A0\\x00-\\x1F\\x7F`!@#$%^&*()+={}\\[\\];:\\'\\\"<>.,\\/\\\\\\?]+$/g.test(name))) {\n\t\treturn \"Invalid character(s)\";\n\t}\n\treturn null;\n};\n\n/*\nReturns null if the argument is an array of valid bag/recipe names, or a string error message if not\n*/\nSqlTiddlerStore.prototype.validateItemNames = function(names) {\n\tif(!$tw.utils.isArray(names)) {\n\t\treturn \"Not a valid array\";\n\t}\n\tvar errors = [];\n\tfor(const name of names) {\n\t\tconst result = this.validateItemName(name);\n\t\tif(result) {\n\t\t\terrors.push(result);\n\t\t}\n\t}\n\tif(errors.length === 0) {\n\t\treturn null;\n\t} else {\n\t\treturn errors.join(\"\\n\");\n\t}\n};\n\nSqlTiddlerStore.prototype.close = function() {\n\tthis.sqlTiddlerDatabase.close();\n\tthis.sqlTiddlerDatabase = undefined;\n};\n\nSqlTiddlerStore.prototype.saveEntityStateTiddler = function(tiddler) {\n\tthis.adminWiki.addTiddler(new $tw.Tiddler(tiddler,{title: this.entityStateTiddlerPrefix + tiddler.title}));\n};\n\nSqlTiddlerStore.prototype.updateAdminWiki = function() {\n\tvar self = this;\n\treturn this.sqlTiddlerDatabase.transaction(function() {\n\t\t// Update bags\n\t\tfor(const bagInfo of self.listBags()) {\n\t\t\tself.saveEntityStateTiddler({\n\t\t\t\ttitle: \"bags/\" + bagInfo.bag_name,\n\t\t\t\t\"bag-name\": bagInfo.bag_name,\n\t\t\t\ttext: bagInfo.description\n\t\t\t});\n\t\t}\n\t\t// Update recipes\n\t\tfor(const recipeInfo of self.listRecipes()) {\n\t\t\tself.saveEntityStateTiddler({\n\t\t\t\ttitle: \"recipes/\" + recipeInfo.recipe_name,\n\t\t\t\t\"recipe-name\": recipeInfo.recipe_name,\n\t\t\t\ttext: recipeInfo.description,\n\t\t\t\tlist: $tw.utils.stringifyList(self.getRecipeBags(recipeInfo.recipe_name).map(bag_name => {\n\t\t\t\t\treturn self.entityStateTiddlerPrefix + \"bags/\" + bag_name;\n\t\t\t\t}))\n\t\t\t});\n\t\t}\n\t});\n};\n\n/*\nGiven tiddler fields, tiddler_id and a bag_name, return the tiddler fields after the following process:\n- Apply the tiddler_id as the revision field\n- Apply the bag_name as the bag field\n*/\nSqlTiddlerStore.prototype.processOutgoingTiddler = function(tiddlerFields,tiddler_id,bag_name,attachment_blob) {\n\tconst fields = Object.assign({},tiddlerFields,{\n\t\trevision: \"\" + tiddler_id,\n\t\tbag: bag_name\n\t});\n\tif(attachment_blob !== null) {\n\t\tdelete fields.text;\n\t\tfields._canonical_uri = `/wiki/${encodeURIComponent(bag_name)}/bags/${encodeURIComponent(bag_name)}/tiddlers/${encodeURIComponent(tiddlerFields.title)}/blob`;\n\t}\n\treturn fields;\n};\n\n/*\n*/\nSqlTiddlerStore.prototype.processIncomingTiddler = function(tiddlerFields) {\n\tlet attachmentSizeLimit = $tw.utils.parseNumber(this.adminWiki.getTiddlerText(\"$:/config/MultiWikiServer/AttachmentSizeLimit\"));\n\tif(attachmentSizeLimit < 100 * 1024) {\n\t\tattachmentSizeLimit = 100 * 1024;\n\t}\n\tif(tiddlerFields.text && tiddlerFields.text.length > attachmentSizeLimit) {\n\t\tconst attachment_blob = this.attachmentStore.saveAttachment({\n\t\t\ttext: tiddlerFields.text,\n\t\t\ttype: tiddlerFields.type,\n\t\t\treference: tiddlerFields.title\n\t\t});\n\t\treturn {\n\t\t\ttiddlerFields: Object.assign({},tiddlerFields,{text: undefined}),\n\t\t\tattachment_blob: attachment_blob\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\ttiddlerFields: tiddlerFields,\n\t\t\tattachment_blob: null\n\t\t};\n\t}\n};\n\nSqlTiddlerStore.prototype.saveTiddlersFromPath = function(tiddler_files_path,bag_name) {\n\tvar self = this;\n\tthis.sqlTiddlerDatabase.transaction(function() {\n\t\t// Clear out the bag\n\t\tself.deleteAllTiddlersInBag(bag_name);\n\t\t// Get the tiddlers\n\t\tvar path = require(\"path\");\n\t\tvar tiddlersFromPath = $tw.loadTiddlersFromPath(path.resolve($tw.boot.corePath,$tw.config.editionsPath,tiddler_files_path));\n\t\t// Save the tiddlers\n\t\tfor(const tiddlersFromFile of tiddlersFromPath) {\n\t\t\tfor(const tiddler of tiddlersFromFile.tiddlers) {\n\t\t\t\tself.saveBagTiddler(tiddler,bag_name,null);\n\t\t\t}\n\t\t}\n\t});\n};\n\nSqlTiddlerStore.prototype.listBags = function() {\n\treturn this.sqlTiddlerDatabase.listBags();\n};\n\nSqlTiddlerStore.prototype.createBag = function(bag_name,description) {\n\tvar self = this;\n\treturn this.sqlTiddlerDatabase.transaction(function() {\n\t\tconst validationBagName = self.validateItemName(bag_name);\n\t\tif(validationBagName) {\n\t\t\treturn {message: validationBagName};\n\t\t}\n\t\tself.sqlTiddlerDatabase.createBag(bag_name,description);\n\t\tself.saveEntityStateTiddler({\n\t\t\ttitle: \"bags/\" + bag_name,\n\t\t\t\"bag-name\": bag_name,\n\t\t\ttext: description\n\t\t});\n\t\treturn null;\n\t});\n};\n\nSqlTiddlerStore.prototype.listRecipes = function() {\n\treturn this.sqlTiddlerDatabase.listRecipes();\n};\n\n/*\nReturns null on success, or {message:} on error\n*/\nSqlTiddlerStore.prototype.createRecipe = function(recipe_name,bag_names,description) {\n\tbag_names = bag_names || [];\n\tdescription = description || \"\";\n\tconst validationRecipeName = this.validateItemName(recipe_name);\n\tif(validationRecipeName) {\n\t\treturn {message: validationRecipeName};\n\t}\n\tconst validationBagNames = this.validateItemNames(bag_names);\n\tif(validationBagNames) {\n\t\treturn {message: validationBagNames};\n\t}\n\tif(bag_names.length === 0) {\n\t\treturn {message: \"Recipes must contain at least one bag\"};\n\t}\n\tvar self = this;\n\treturn this.sqlTiddlerDatabase.transaction(function() {\n\t\tself.sqlTiddlerDatabase.createRecipe(recipe_name,bag_names,description);\n\t\tself.saveEntityStateTiddler({\n\t\t\ttitle: \"recipes/\" + recipe_name,\n\t\t\t\"recipe-name\": recipe_name,\n\t\t\ttext: description,\n\t\t\tlist: $tw.utils.stringifyList(bag_names.map(bag_name => {\n\t\t\t\treturn self.entityStateTiddlerPrefix + \"bags/\" + bag_name;\n\t\t\t}))\n\t\t});\n\t\treturn null;\n\t});\n};\n\n/*\nReturns {tiddler_id:}\n*/\nSqlTiddlerStore.prototype.saveBagTiddler = function(incomingTiddlerFields,bag_name) {\n\tconst {tiddlerFields, attachment_blob} = this.processIncomingTiddler(incomingTiddlerFields);\n\treturn this.sqlTiddlerDatabase.saveBagTiddler(tiddlerFields,bag_name,attachment_blob);\n};\n\n/*\nCreate a tiddler in a bag adopting the specified file as the attachment. The attachment file must be on the same disk as the attachment store\nOptions include:\n\nfilepath - filepath to the attachment file\nhash - string hash of the attachment file\ntype - content type of file as uploaded\n\nReturns {tiddler_id:}\n*/\nSqlTiddlerStore.prototype.saveBagTiddlerWithAttachment = function(incomingTiddlerFields,bag_name,options) {\n\tconst attachment_blob = this.attachmentStore.adoptAttachment(options.filepath,options.type,options.hash);\n\tif(attachment_blob) {\n\t\treturn this.sqlTiddlerDatabase.saveBagTiddler(incomingTiddlerFields,bag_name,attachment_blob);\n\t} else {\n\t\treturn null;\n\t}\n};\n\n/*\nReturns {tiddler_id:,bag_name:}\n*/\nSqlTiddlerStore.prototype.saveRecipeTiddler = function(incomingTiddlerFields,recipe_name) {\n\tconst {tiddlerFields, attachment_blob} = this.processIncomingTiddler(incomingTiddlerFields);\n\treturn this.sqlTiddlerDatabase.saveRecipeTiddler(tiddlerFields,recipe_name,attachment_blob);\n};\n\nSqlTiddlerStore.prototype.deleteTiddler = function(title,bag_name) {\n\tthis.sqlTiddlerDatabase.deleteTiddler(title,bag_name);\n};\n\n/*\nreturns {tiddler_id:,tiddler:}\n*/\nSqlTiddlerStore.prototype.getBagTiddler = function(title,bag_name) {\n\tvar tiddlerInfo = this.sqlTiddlerDatabase.getBagTiddler(title,bag_name);\n\tif(tiddlerInfo) {\n\t\treturn Object.assign(\n\t\t\t{},\n\t\t\ttiddlerInfo,\n\t\t\t{\n\t\t\t\ttiddler: this.processOutgoingTiddler(tiddlerInfo.tiddler,tiddlerInfo.tiddler_id,bag_name,tiddlerInfo.attachment_blob)\n\t\t\t});\t\n\t} else {\n\t\treturn null;\n\t}\n};\n\n/*\nGet an attachment ready to stream. Returns null if there is an error or:\nstream: stream of file\ntype: type of file\n*/\nSqlTiddlerStore.prototype.getBagTiddlerStream = function(title,bag_name) {\n\tconst tiddlerInfo = this.sqlTiddlerDatabase.getBagTiddler(title,bag_name);\n\tif(tiddlerInfo) {\n\t\tif(tiddlerInfo.attachment_blob) {\n\t\t\treturn this.attachmentStore.getAttachmentStream(tiddlerInfo.attachment_blob);\n\t\t} else {\n\t\t\tconst { Readable } = require('stream');\n\t\t\tconst stream = new Readable();\n\t\t\tstream._read = function() {\n\t\t\t\t// Push data\n\t\t\t\tconst type = tiddlerInfo.tiddler.type || \"text/plain\";\n\t\t\t\tstream.push(tiddlerInfo.tiddler.text || \"\",($tw.config.contentTypeInfo[type] ||{encoding: \"utf8\"}).encoding);\n\t\t\t\t// Push null to indicate the end of the stream\n\t\t\t\tstream.push(null);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tstream: stream,\n\t\t\t\ttype: tiddlerInfo.tiddler.type || \"text/plain\"\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn null;\n\t}\n};\n\n/*\nReturns {bag_name:, tiddler: {fields}, tiddler_id:}\n*/\nSqlTiddlerStore.prototype.getRecipeTiddler = function(title,recipe_name) {\n\tvar tiddlerInfo = this.sqlTiddlerDatabase.getRecipeTiddler(title,recipe_name);\n\tif(tiddlerInfo) {\n\t\treturn Object.assign(\n\t\t\t{},\n\t\t\ttiddlerInfo,\n\t\t\t{\n\t\t\t\ttiddler: this.processOutgoingTiddler(tiddlerInfo.tiddler,tiddlerInfo.tiddler_id,tiddlerInfo.bag_name,tiddlerInfo.attachment_blob)\n\t\t\t});\n\t} else {\n\t\treturn null;\n\t}\n};\n\n/*\nGet the titles of the tiddlers in a bag. Returns an empty array for bags that do not exist\n*/\nSqlTiddlerStore.prototype.getBagTiddlers = function(bag_name) {\n\treturn this.sqlTiddlerDatabase.getBagTiddlers(bag_name);\n};\n\n/*\nGet the titles of the tiddlers in a recipe as {title:,bag_name:}. Returns null for recipes that do not exist\n*/\nSqlTiddlerStore.prototype.getRecipeTiddlers = function(recipe_name) {\n\treturn this.sqlTiddlerDatabase.getRecipeTiddlers(recipe_name);\n};\n\nSqlTiddlerStore.prototype.deleteAllTiddlersInBag = function(bag_name) {\n\tvar self = this;\n\treturn this.sqlTiddlerDatabase.transaction(function() {\n\t\treturn self.sqlTiddlerDatabase.deleteAllTiddlersInBag(bag_name);\n\t});\n};\n\n/*\nGet the names of the bags in a recipe. Returns an empty array for recipes that do not exist\n*/\nSqlTiddlerStore.prototype.getRecipeBags = function(recipe_name) {\n\treturn this.sqlTiddlerDatabase.getRecipeBags(recipe_name);\n};\n\nexports.SqlTiddlerStore = SqlTiddlerStore;\n\n})();","tags":"","title":"$:/plugins/tiddlywiki/multiwikiserver/store/sql-tiddler-store.js","modified":"20240318125529727","type":"application/javascript","module-type":"library"}
]
